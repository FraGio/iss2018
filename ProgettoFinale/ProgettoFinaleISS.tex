\documentclass{../libs/llncs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% package sillabazione italiana e uso lettere accentate
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{url}
\usepackage{xspace}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{../libs/manifest}

\makeatother


%%%%%%%
 \newif\ifpdf
 \ifx\pdfoutput\undefined
 \pdffalse % we are not running PDFLaTeX
 \else
 \pdfoutput=1 % we are running PDFLaTeX
 \pdftrue
 \fi
%%%%%%%
 \ifpdf
 \usepackage[pdftex]{graphicx}
 \else
 \usepackage{graphicx}
 \fi
%%%%%%%%%%%%%%%
 \ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg, .tif}
 \else
 \DeclareGraphicsExtensions{.eps, .jpg}
 \fi
%%%%%%%%%%%%%%%

\newcommand{\java}{\textsf{Java}}
\newcommand{\contact}{\emph{Contact}}
\newcommand{\corecl}{\texttt{corecl}}
\newcommand{\medcl}{\texttt{medcl}}
\newcommand{\msgcl}{\texttt{msgcl}}
\newcommand{\android}{\texttt{Android}}
\newcommand{\dsl}{\texttt{DSL}}
\newcommand{\jazz}{\texttt{Jazz}}
\newcommand{\rtc}{\texttt{RTC}}
\newcommand{\ide}{\texttt{Contact-ide}}
\newcommand{\xtext}{\texttt{XText}}
\newcommand{\xpand}{\texttt{Xpand}}
\newcommand{\xtend}{\texttt{Xtend}}
\newcommand{\pojo}{\texttt{POJO}}
\newcommand{\junit}{\texttt{JUnit}}

\newcommand{\action}[1]{\texttt{#1}\xspace}
\newcommand{\code}[1]{{\small{\texttt{#1}}}\xspace}
\newcommand{\codescript}[1]{{\scriptsize{\texttt{#1}}}\xspace}

% Cross-referencing
\newcommand{\labelsec}[1]{\label{sec:#1}}
\newcommand{\xs}[1]{\sectionname~\ref{sec:#1}}
\newcommand{\xsp}[1]{\sectionname~\ref{sec:#1} \onpagename~\pageref{sec:#1}}
\newcommand{\labelssec}[1]{\label{ssec:#1}}
\newcommand{\xss}[1]{\subsectionname~\ref{ssec:#1}}
\newcommand{\xssp}[1]{\subsectionname~\ref{ssec:#1} \onpagename~\pageref{ssec:#1}}
\newcommand{\labelsssec}[1]{\label{sssec:#1}}
\newcommand{\xsss}[1]{\subsectionname~\ref{sssec:#1}}
\newcommand{\xsssp}[1]{\subsectionname~\ref{sssec:#1} \onpagename~\pageref{sssec:#1}}
\newcommand{\labelfig}[1]{\label{fig:#1}}
\newcommand{\xf}[1]{\figurename~\ref{fig:#1}}
\newcommand{\xfp}[1]{\figurename~\ref{fig:#1} \onpagename~\pageref{fig:#1}}
\newcommand{\labeltab}[1]{\label{tab:#1}}
\newcommand{\xt}[1]{\tablename~\ref{tab:#1}}
\newcommand{\xtp}[1]{\tablename~\ref{tab:#1} \onpagename~\pageref{tab:#1}}
% Category Names
\newcommand{\sectionname}{Section}
\newcommand{\subsectionname}{Subsection}
\newcommand{\sectionsname}{Sections}
\newcommand{\subsectionsname}{Subsections}
\newcommand{\secname}{\sectionname}
\newcommand{\ssecname}{\subsectionname}
\newcommand{\secsname}{\sectionsname}
\newcommand{\ssecsname}{\subsectionsname}
\newcommand{\onpagename}{on page}

%AUTH
\newcommand{\xauthA}{Andrea Torchi }
\newcommand{\xauthB}{Francesco Giovanelli}
\newcommand{\xauthC}{Giuseppe Tempesta }

\newcommand{\xfaculty}{II Faculty of Engineering}
\newcommand{\xunibo}{Alma Mater Studiorum -- University of Bologna}
\newcommand{\xaddrBO}{viale Risorgimento 2}
\newcommand{\xaddrCE}{via Venezia 52}
\newcommand{\xcityBO}{40136 Bologna, Italy}
\newcommand{\xcityCE}{47023 Cesena, Italy}

%
% Comments
%
%%% \newcommand{\todo}[1]{\bf{TODO:}\emph{#1}}


\begin{document}

\title{Software Engineering\\
 process report template}

%%% \author{\xauthA \and \xauthB}
\author{\xauthA \, \xauthB \, \xauthC}

\institute{%
	%%%  \xunibo\\\xaddrCE, \xcityCE\\\email{\{nameA.studentA, nameB.studentB\}@studio.unibo.it}
	\xunibo\\\xaddrCE, \xcityCE\\\email\ andrea.torchi@studio.unibo.it\\
	francesco.giovanelli@studio.unibo.it\\
    giuseppe.tempesta2@studio.unibo.it
}

\maketitle

%% \begin{abstract}
%% \footnotesize
%%This a Latex template to be used for the reports of Software Engineering.
%%\keywords{Software engineering, managed software development, reports, ....}
%%\end{abstract}

%%% \sloppy

%===========================================================================
\section{Introduction}
\labelsec{intro}
Questo modulo rappresenta una fotografia, in un questo istante, del processo di sviluppo del software. Avere una documentazione completa circa tutte le fasi (Analisi, Progettazione, Implementazione, Testing) è importante per far mantenere una traccia delle considerazioni emerse nelle fasi già citate e, soprattutto, il giusto flusso di sviluppo, che parte dai requisiti, fino ad arrivare ad un prodotto finale che è in linea con le attese del committente. \\
Possiamo approcciare i problemi che emergono in modo olistico (top-down), o riduzionistico (bottom-up). 
Cosa s'intende per top-down o bottom-up?\\
TOP-DOWN, cioè procedendo dall'alto verso il basso, quindi partendo da specifiche di alto livello, analizzando i sottosistemi ed arrivando ad una soluzione; questo approccio è in linea con una visione OLISTICA, ovvero che non si concentra sulle singole parti, ma ha una visione "più d'insieme" o di alto livello. \\
BOTTOM-UP, cioè procedendo dal basso verso l'alto, quindi partendo più da componenti, per poi passare alla loro sintesi. Questo approccio è in linea con una visione RIDUZIONISTA, opposta alla precedente, la quale mira a porre l'attenzione sulle singole parti di un certo sistema, piuttosto che sull'insieme intero.\\
%===========================================================================

%===========================================================================
\section{Vision}
\labelsec{Vision}
La "Visione" è una frase che fa capire come ci si approcci alle cose, ovvero come affrontare problemi.
Lo scopo dell'analisi dei requisiti è quello di capire il problema, analizzando i requisiti ed evidenziando aspetti problematici, successivamente, produrre (in modo formale) uno o più modelli che rappresentino il sistema. \\
Possibile affrontare un problema partendo da zero? Senza alcuna ipotesi? Molto difficile, quasi impensabile!
Partire dal foglio bianco significa non avere alcuna ipotesi tecnologica (come se si partisse assolutamente privi di informazioni, non ho nulla su cui orientarmi). \\
La questione che adesso ci si pone è l'affrontare un problema partendo da ipotesi tecnologiche e poi arrivando ad una soluzione utilizzando gli strumenti che si conoscono (approccio bottom-up). L'approccio giusto, in ogni caso, è decidere il più tardi possibile quale tecnologia utilizzare, poichè si vuole trovare quella giusta(la tecnologia), al momento giusto. Non si costruisce in funzione della "scatola lego" (cioè dei pezzi che hai a disposizione), ma si analizza quello che si vuol fare e, solo dopo si cerca la "scatola lego" più opportuna a per quello che si vuol realizzare. \\
La visione adottata in questo caso è:
"Dalle tecnologie alla analisi e al progetto logico e ritorno alle tecnologie." 
Cosa significa? \\
Dopo aver capito che comunque si deve partire dalle tecnologie (e quindi non si può partire da zero, senza alcuna contaminazione tecnologica), si fanno delle ipotesi su cosa fare. Poi ci si occupa di analisi dei requisiti. Successivamente si ritorna alle tecnologie per poter dire se si ha un "abstraction-gap". Se per ogni byte di codice di business se ne devono scrivere 100 per l'infrastruttura, significa che c'è un abstraction gap enorme. Quindi la tecnologia che sto utilizzando è insufficiente, o meglio, inappropriata per il mio problema, e, di conseguenza, il tempo richiesto per lo sviluppo e il mantenimento dell'infrastruttura è eccessivo. \\
Si parla di "tecnology-lock" se l'applicazione è strettamente contaminata dalla tecnologia, ovviamente questa caratteristica potrebbe rappresentare un problema. Questo accade quando la scelta della tecnologia viene fatta prima rispetto le scelte di analisi/progetto; si contamina/rende strettamente dipendente il sistema finale dalla tecnologia. \\
Altra cosa importante da tenere a mente è: "non c'è codice senza progetto, non c'è progetto senza analisi e non c'è analisi senza requisiti". 
%===========================================================================

%===========================================================================
\section{Goals}
\labelsec{Goals}
L'obbiettivo principale è produrre e sviluppare software con criteri di qualità, in termini di prodotto e di processo.
%===========================================================================

%===========================================================================
\section{Requirements}
\labelsec{Requirements}
In a home of a given city (e.g. Bologna), a ddr robot is used to clean the foor of a room ( R-FloorClean ).\\
The floor in the room is a flat floor of solid material and is equipped with two sonars , named sonar1 and
sonar2 as shown in the picture ( sonar1 is that at the top). The initial position ( start-point ) of the robot is
detected by sonar1 , while the final position ( end-point ) is detected by sonar2 . \\
The robot works under the following conditions:\\
\begin{enumerate}
\item R-Start : an authorized user has sent a START command by using a human GUI interface ( console ) running
on a conventional PC or on a smart device ( Android ).
\item R-TempOk : the value temperature of the city is not higher than a prexed value (e.g. 25 degrees Celsius).
\item R-TimeOk : the current clock time is within a given interval (e.g. between 7 a.m and 10 a.m )
\end{enumerate}
While the robot is working: \\
\begin{itemize}
\item it must blink a Led put on it, if the robot is a real robot ( R-BlinkLed ).
\item it must blink a Led Hue Lamp available in the house, if the robot is a virtual robot ( R-BlinkHue ).
\item it must avoid fixed obstacles (e.g. furniture) present in the room ( R-AvoidFix ) and/or mobile obstacles like balls, cats, etc. ( R-AvoidMobile ).
\end{itemize}

Moreover, the robot must stop its activity when one of the following conditions apply:\\
\begin{enumerate}
\item R-Stop : an authorized user has sent a STOP command by using the console.
\item R-TempKo : the value temperature of the city becomes higher than the prefixed value.
\item R-TimeKo : the current clock time is beyond the given interval.
\item R-Obstacle : the robot has found an obstacle that it is unable to avoid.
\item R-End : the robot has finished its work.
\end{enumerate}

During its work, the robot can optionally: \\
\begin{itemize}
\item R-Map : build a map of the room floor with the position of the fixed obstacles. Once built, this map can be
used to define a plan for an (optimal) path form the start-point to the end-point .
\end{itemize}

Other requirements:\\
\begin{enumerate}
\item The work can be done by a team composed of NT people, with 1<=NT<=4 .
\item If NT>1 , the team must explicitly indicate the work done by each component.
\item If NT==4 , the requirement R-Map is mandatory.
\end{enumerate}
%===========================================================================

 
%===========================================================================
\section{Requirement analysis}
\labelsec{ReqAnalysis}

In base ai requisiti dati emergono alcune considerazioni o dubbi da chiarire.\\
\begin{itemize}
\item R-FloorClean: sappiamo che è presente un'entità "robot" che opera in una stanza di una abitazione, in una determinata città. La stanza di un ambiente domestico è definita come un qualsiasi spazio chiuso con pavimento solido e piatto. Il reqeuisito ci dice anche che il robot è tenuto a pulire il pavivento della stanza.\\
Per pulire il pavimento della stanza il robot deve coprire tutta l'area del pavimento.\\
Apprendiamo inoltre che la stanza è dotata di due sonar che rappresentano la posizione iniziale e quella finale che il robot deve raggiungere.\\
\item R-Start: questo requisito implica che nel sistema è presente una seconda entità, rappresentata dal PC/smartphone, che si affianca all'entità robot. Deduciamo anche che il robot possa assumere uno stato di "working" dove esso sta lavorando.\\
La GUI deve essere messa a disposizione dal PC/smartphone, e sarà utilizzata dall'utente autorizzato per inviare comandi di START.\\
L'utente autorizzato è un utente il quale ha effettuato un accesso sul sistema utilizzando le credenziali a sua disposizione.\\ Questo comporta la presenza di un sistema di autenticazione utenti che dovrà essere presente in una delle due entità in gioco o su sistemi esterni.\\
Il requisito ci dice anche che il comando inviato tramite GUI deve raggiungere il robot e cambiarne lo stato.\\
\item R-TempOk: ci dà un vincolo sulla temperature massima della città tollerata dal robot, sotto la quale può lavorare. Il valore di soglia, basandoci anche sull'interrogazione del committente, è a nostra discrezione.\\
Il requisito non specifica come il robot ottiene il valore di temperatura, in quanto il robot non è dotato di un proprio sensore in grado di rilevarla. Quindi la temperatura deve essere fornita o reperita da un'entità/servizio esterno/a.\\
\item R-TimeOk: il robot può lavorare soltanto all'interno di un intervallo temporale (nell'arco delle 24 ore di una giornata) prefissato. L'intervallo non è specificato nei requisiti ed è quindi a nostra discrezione.\\
Non è specificato come il robot tiene traccia dell'andamento temporale, ma il committente ha dichiarato che il robot può avere un proprio clock interno.\\
\item R-BlinkLed: apprendiamo che possa essere presente un robot reale, e, se è così, che il robot reale sia dotato di un led, dove led è un dispositivo elettronico a semiconduttore che al passaggio di corrente elettrica emette luce. Il led deve lampeggiare qualora il robot si trovi in stato di "working".
\item R-BlinkHue: sappiamo che la casa è dotata di una Led Hue Lamp. La Led Hue Lamp in questione deve lampeggiare fintanto che il robot virtuale è in stato di working. Apprendiamo che possa essere presente un robot virtuale, e, se è così, che durante la sua attività, debba lampeggiare la Led Hue Lamp presente nella stanza.\\ 
Non è specificato chi comandi la lampada.\\
\item R-AvoidFix: ci dice che nella stanza possono essere presenti ostacoli fissi, dove l'ostacolo fisso è definito come persona o entità che occupa l'area di azione del robot e che non effettua alcun movimento proprio (ad esempio mobilio). Durante la sua attività il robot deve evitare questo tipo di ostacolo (se presente), dove per "evitare" intendiamo il modificare la propria traiettoria in modo da non entrare in contatto con esso pur continuando la sua attività.\\
\item R-AvoidMobile: ci dice che nella stanza possono essere presenti ostacoli mobili, dove l'ostacolo mobile è definito come persona o entità che occupa l'area di azione del robot e che si muove liberamente. Durante la sua attività il robot deve evitare questo tipo di ostacolo (se presente), dove per "evitare" intendiamo il modificare, o sospendere, la propria traiettoria in modo da non entrare in contatto con esso pur continuando la sua attività.\\
In base ai due requisiti appena analizzati deduciamo che il robot debba poter percepire ostacoli esterni, non è espresso come.\\
\item R-Stop: apprendiamo che tramite la GUI fornita, l'utente autorizzato possa inviare anche comandi di STOP, i quali dovranno avere come effetto l'interruzione dell'attività del robot.\\
\item R-TempKo: da questo requisito deduciamo che sia necessario fornire al robot informazioni sulle variazioni di temperatura, in modo che, superata una certa soglia, l'attività del robot si interrompa. Valgono le considerazioni fatte per l'R-TempOk sul modo in cui reperisce i dati di temperatura.\\
\item R-TimeKo: apprendiamo che, se il valore temporale supera il valore massimo dell'intervallo di lavoro consentito, il robot deve cessare la sua attività. Valgono le considerazioni fatte per R-TimeOk sui valori dell'intervallo.\\
\item R-Obstacle: ci dice che è possibile che sia presente un ostacolo inevitabile, cioè un entità posizionata nell'area di lavoro che si frappone tra il robot e il sonar finale e impedisce, tramite qualsiasi movimento possibile al robot, di raggiungere il sonar finale. Di conseguenza, in questa condizione, il robot deve arrestarsi.\\
\item R-End: Come si capisce che il robot ha raggiunto il sonar? In base R-FloorClean sappiamo che è il sonar finale a rilevare la presenza del robot, quindi, una volta che il robot ha raggiunto il sonar finale deve arrestarsi
\end{itemize}

%===========================================================================
\subsection{Use cases}
\labelssec{UseCases}

\subsection{Scenarios}
\labelssec{Scenarios}

\subsection{(Domain)model}
La modellazione può essere eseguita in maniera formale o non formale. Nel primo caso si utilizza un linguaggio (UML, QActor, ecc.) tramite il quale è possibile esprimere modelli comprensibili non solo dall'uomo ma anche da una macchina. \\
A noi interessa modellare in maniera formale.

Formalizziamo le entità espresse nei requisiti:
\begin{itemize}
\item Robot fisico: robot di tipo Mbot, dotato di ruote per il movimento
\item Robot virtuale:
\item Led: led di marca ELEGOO, dove led è un dispositivo elettronico a semiconduttore che al passaggio di corrente elettrica emette luce.
\item Led Hue Lamp: lampada Philips Led Hue Lamp, che è una lampada a led collegabile a rete internet tramite WiFi e, di conseguenza, controllabile da remoto tramite dipositivi elettronici (smartphone).
\item Sonar: i sonar sono sonar di tipo Me Ultrasonic Sensor V3.0.
\item 
\end{itemize}


\subsection{Test plan}

%===========================================================================
\section{Problem analysis}
\labelsec{ProblemAnalysis}
Scopo dell'analisi del problema è la produzione di un modello formale. Cosa significa? Che può essere eseguito su una macchina. Come può essere fatto? Attraverso un linguaggio (di modellazione, eventualmente) che riesca a catturare gli aspetti fondamentali del sistema, ovvero al giusto livello di dettaglio, mettendo in primo piano aspetti rilevanti, e lasciando in "background" dettagli. Il modello è espresso in termini di STRUTTURA, INTERAZIONE e COMPORTAMENTO. Limitatamente al nostro caso, ci è fornito un linguaggio di modellazione custom, QActor, grazie al quale modelliamo il sistema. 

%===========================================================================
\subsection{Logic architecture}
\subsection{Abstraction gap}

\subsection{Risk analysis}

%===========================================================================
\section{Work plan}
\labelsec{wplan}
Ci occupiamo di scegliere l'opportuno processo produttivo, in cui ci sono due scuole in contrasto: l'agile (di cui scrum è un esempio) e model based. \\
Agile development consiste in lavorare in gruppi auto organizzati, multifunzionali e orientati allo stretto contatto con il cliente finale, al fine di ottenere prodotti utilizzabili in tempo rapido, di migliorare costantemente i prodotti stessi e di rimanere flessibili a ipotetici cambiamenti resisi necessari nel tempo.\\
Model based development impone che,prima di trattare il codice, sia necessario occuparsi della fase di modellazione. Solo in un secondo momento si passerà alla fase di sviluppo vero e proprio, tenendo opportunamente aggiornata la parte di modello.\\
In questa fase entra in gioco anche il testing, che è fondamentale per assicurare solidità e riddure al minimo i rischi di bug critici in fase di produzione. I test possono essere fatti non solo alla fine della costruzione del sistema, ma anche, e soprattutto, durante. Un'ulteriore aspetto da considerare è che i test possono anche essere resi automatizzati.\\
%===========================================================================

%===========================================================================
\section{Project}
\labelsec{Project}
La fase di progetto, svolta dal progettista, prende in input il lavoro svolto dall'analista, ovvero il modello formale che descrive il sistema e propone, a sua volta, un ulteriore modello, nel quale vengono specificati e risolti problemi lasciati in sospeso dall'analista (e.g. quale protocollo? ). 
Anche in questo caso il sistema è specificato in termini di STRUTTURA, INTERAZIONE e COMPORTAMENTO. 
%===========================================================================

\subsection{Structure}
\subsection{Interaction}
\subsection{Behavior}

%===========================================================================
\section{Implementation}
\labelsec{Implementation}
%===========================================================================

%===========================================================================
\section{Testing}
\labelsec{testing}
Molto importante la fase di testing in cui viene testato il prodotto ottenuto. Il tutto dovrebbe essere fatto il linea con la filosofia di testare tutto al fine di provare il sistema il prima possibile. \\
Possibile parlare di testing manuale o automatico. Nel primo caso occorrerà dare in pasto al sistema dei valori ed assicurarsi che l'output sia in linea con le aspettative. Nel secondo caso si possono utilizzare strumenti di testing automatico (e.g. JUNIT), i quali, una volta eseguiti, testano le componenti specificate, riportando in output eventuali problemi e dove essi si sono verificati. 
%===========================================================================

%===========================================================================
\section{Deployment}
\labelsec{Deployment}
%===========================================================================

%===========================================================================
\section{Maintenance}
\labelsec{Maintenance}
%===========================================================================
\newpage
See \cite{natMol09} until page 11 (\texttt{CMM}) and pages 96-105.

%===========================================================================
\section{Information about the author}
\labelsec{Author}
%===========================================================================

\vskip.5cm
%%% \begin{figure}
\begin{tabular}{ | c |  }
\hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  Photo of the author 
  \\
\hline
   %\includegraphics[scale = 0.3]{}
  \\
\hline
\end{tabular}


%%% \begin{itemize}
%%% \item Titolo di studio:\\ \\
%%% \item Interessi particolari:\\ \\
%%% \item Ha sostenuto fino ad oggi il seguente numero di esami:\\ \\
%%% \item Deve ancora sostenere i seguenti esami del I anno:\\ \\
%%% \item Prevede di svolgere un tirocinio presso:\\ \\
%%% \item Prevede di laurearsi nella sessione:\\ \\
%%% \item Intende proseguire gli studi per conseguire: \\  \\  \\
%%%   	presso la sede universitaria di: \\ \\
%%% \item Intende entrare subito nel mondo del lavoro presso : \\ \\
%%% \end{itemize}

 
\appendix


\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}












