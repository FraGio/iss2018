Pull dalle repositories.

L'idea è di sostituire il led con il robot. Vogliamo comandare il robot con l'utilizzo di comandi (machine to machine, poi human to machine) RESTful.
RESTful significa che sfrutto interazioni HTTP con GET, PUT, ...
Questi sono i requisiti.

Apriamo il progetto "frontend". In "iss2018Lab/it.unibo.frontend/WebGLScene/" ci sono le scene, ognuno può farsi le proprie.

Dati i requisiti detti passiamo alle fasi di analisi, progetto e sviluppo.
Voglio interagire con il robot con richieste HTTP per muoversi.
Il robot può essere anche quello virtuale che abbiamo già a nostra disposizione.

Facciamo le domande a committente/boss/proj. manager e le risposte sono:
    Le azioni che deve compiere il robot sono le solite (forward, back, right, left).
    il committente ha un suo robot fisico
    
Andiamo a pag. 29 delle dispense "nodeLab2018.pdf". Il requisito R0B è quello sulla temperatura. Ci sono due figure informali, una a sinistra e una a destra.
Quella di sx è un modo di mostrare i componenti che ci vengono dati, con i quali devo avere a che fare, e che sono input e output.
La "scatola" può ricevere comandi RESTful, oppure può generarli ed inviarli al robot (nel nostro esempio di oggi con robot=led). Possiamo pensare che la scatola generi comandi RESTful e faccia in modo che il mio robot si muova in accordo ad essi.
Siamo in progettazione top-down con zooming incrementale sulla architettura. All'inizio vedo una black box.
Non mi interessa chi manda i comandi RESTful, può essere una macchina o un utente, basta che questi comandi agiscano sul robot opportunamente.
Adesso guardiamo cosa c'è dentro la scatola (figura di dx).

Se l'analista dice che serve l'architettura esagonale sembra che il problema richieda questa cosa, mentre non è così. Quindi è il progettista che fa questa considerazione, perchè si concentra sul come, non sul cosa.

I ragionamenti fatti la scorsa volta, e nella figura a destra, sono validi anche per fare l'analisi del problema dato oggi?
Dobbiamo capire se la figura deriva dall'analisi o dalla progettazione. E' di progetto, perchè il led si può accendere anche in modo diverso, non ero costretto dal problema a fare così. Era stato usato un pattern, ma nessuno obbliga ad utilizzarlo.
Il led è espresso in maniera informale nella figura (LED1), c'è qualcosa che lo formalizza? Ci vuole un modello di led 1.

C'è un robot virtuale, con cui possiamo interagire tramite l'invio di messaggi.
C'è un nuovo robot fatto in javascript (slide 30), tramite il quale posso interagire. Mi posso collegare come server a una certa porta (8999), e devo parlargli tramite una scritta Json.
Il robot fisico ed il robot di Unity avevano un altro modo di interagire con esso, quindi ogni robot è fatto con una sua precisa tecnologia. Voglio comunicare in modo technology independent, da qui il fatto di usare gli adapter.

Guardiamo se nel progetto "frontend" c'è qualcosa per interagire con questo nuovo robot. C'è un file "mbotConnTcp.java". Facendo partire il server di Soffritti e quella classe il robot dovrebbe muoversi.
Scarichiamo la repo di Soffritti e, seguendo le istruzioni, lanciamo il server.

*** non parte, farlo partire ***

Finora abbiamo affrontato la parte di analisi, cioè come è fatto un robot e come interagisco con esso. Il robot che abbiamo sott'occhio non è un pojo, perchè è in ascolto su una porta. Il robot è un attore? O addirittura un agente?

La semantica di cosa intendiamo per oggetto qual è? Non possiamo dare una definizione fuffosa, come "un entità passiva e non dotata di flusso di controllo proprio".

Domanda fondamentale per tutto il corso: perchè la definizione di oggeto non può essere fuffosa? Tanto non viene interpretata da una macchina.
Perchè l'interpretazione deve essere chiara e ben definita, lo scambio di informazioni è il punto fondamentale per l'informatica.

Se dico "mi accompagni a Modena?" devo prima definire cos'è Modena, potrebbe essere una stazione spaziale o una città o altro. Quindi devo FORMALIZZARE le coordnate geografiche di Modena. La semantica deve essere univoca!

Quindi tornando alla definizione di oggetto: per oggetto intendiamo un oggetto Java. In questo modo non c'è ambiguità su struttura, interazione e comportamento, perchè Java è uno standard, non c'è ambiguità.

Allo stesso modo qual è la definizione di agente? Ci sarà un linguaggio FORMALE, cioè interpretabile allo stesso modo da tutti, che definisce un agente.

Quindi potrei dire che un oggetto è per me un oggetto javascript, perchè ha la concezione di oggetti che sono quindi ben definiti e formalizzati, mentre non posso dire che l'oggetto è un qualsiasi oggetto C, perchè potrei avere varie interpretazioni e implementazioni degli oggetti in C (es. tramite librerie).

Torniamo al punto originale: possiamo dire che il robot fatto da Soffritti sia un POJO? No. Posso dire che sia un actor? No. Un QActor? No, formalmente non lo è ma si può vedere come un QActor, questo perchè è un'entità con la quale interagisco tramite scambio di messaggi.

Soffritti non ci ha dato un actor, ma potrebbe essere comodo fare un involucro per interpretarlo come un actor, e per farlo creo un modello qa che formalizza.
L'actor si metterà in attesa di messaggi inviati dall'esterno, interpreterà i comandi, creerà un client tcp che si collega al server col robot, e invierà i giusti messaggi al server per comandare il robot.

Stiamo riempiendo la "scatola" della figura, manca RESTful. Mi servirà un frontend che mi permetta di inviare comandi tramite RESTful.
Se uso l'opzione -httpserver nel QActor non ho un server RESTful, ho un server http normale. Dovrei cambiare il server tcp built-in con uno RESTful, ma quello che funziona non si tocca, per cui meglio farne un altro (tecnologia javascript).

L'architettura logica è fatta da quanti elementi? C'è il sistema di Soffritti, che è l'equivalente del led nell'esempio precedente. Ci sarà un componente adapter che posso modellare come QActor, che se qualcuno gli invia un messaggio lo traduce come messaggio interpretabile dal sistema di Soffritti.
Ci sarà anche un frontend server che aspetta interazioni RESTful e che le gira al QActor.

Piano di lavoro: primo passo è creare il QActor (più testing), il secondo è fare il frontend.

Il frontend può interagire col robot passando per il QActor.
E' meglio un middleware a QActor o un middleware java? Farli entrambi, dividendo i lavori su persone diverse, mi dà più flessibilità.

Non abbiamo discusso del resource model.

Il QActor (middleware) potrebbe, oltre ad interpretare i comandi e inviarli al robot, anche ottenere le info sullo stato del sistema e girarle al frontend, in modo da mostrarle in tempo reale senza che vengano richieste esplicitamente. Questo lo rende anche emettitore di eventi.

L'idea è di fare un robot aspirapolvere, cioè pulire tutta l'area a sua disposizione. Potrebbero esserci ostacoli mobili (es. gatto).

Guardiamo file socketIOFrontendServer.js in progetto frontend: la riga 4 è commentata, la 5 è quella nuova. Facendolo partire dovrebbe comparire una pagina per inviare comandi al robot, se gli altri componenti sono attivi.
