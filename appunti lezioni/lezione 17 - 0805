Fatti pull, rimesse librerie 1.5.14, aggiornata libreria qa18akka.jar (con gradle -build).
Il nostro goal non è accendere il led, ma pianificare il lavoro per accendere il led, quindi dobbiamo enfatizzare la parte di progetto e soprattutto di analisi.
Voglio pensare all'accensione del led in tutte le combinazioni possibili.
Arduino con il led può essere collegato al nostro pc o a un altro dispositivo, poi l'accensione del led andrà fatta anche per il raspberry.
Arduino è microcotrollore, fa le cose semplici, mentre raspberry è come un computer ma con i pin.
Si vuole organizzare il piano di produzione, prima accenno formalmente delle architetture (perchè lavoriamo su sistemi). In una prima fase si discute delle architetture in maniera informale, poi si formalizza catturando i principi fondamentali.
Il passaggio da Arduino a raspberry deve essere semplicissimo, non devo partire dalla tecnologia e legarmi ad essa fin dall'inizio.
Apriamo il nodeLab2018.
La prima fase è sempre l'analisi dei requisiti, nella quale esprimo cosa sono le entità in gioco per chiarire i requisiti (es. cos'è un led).
Nel pdf OurButton e OurLed sono elementi che si "mangiano" il bottone e il led, non è detto siano gli stessi intesi dal committente.
Il quarto caso vuol dire che chiunque ci vende il button ci darà anche un pezzo di sw che lo rende observable.
Nel quinto caso non vogliamo mettere logica applicativa nel button o nell'observer, ma la metto in un'entità terza.
In questa fase la scelta dell'architettura deriva dall'analisi, noi scegliamo la penultima.
Il prossimo passo è quello di formalizzare l'architettura, non voglio passare degli "scarabocchi" ad altre persone/fasi. Posso formalizzare con UML, ma le entità saranno rappresentate come classi che interagiranno tramite procedure call.
Noi siamo in un sist. distribuito, con tre componenti.
Il button alla fine è qualcosa che dò in mano a un utente umano con il quale esso esercita il controllo. 
Prendiamo il QA fatto l'ultima volta. C'era un'interazione ad eventi.
Aperto IDE di Arduino. Arduino nella vita esegue un loop. Guardiamo il file di arduino (Led13Msg.ino, in progetto "divide"). Agli occhi del progetto la stringa ""msg( info,..." corrisponde ad un evento emesso.
Vogliamo formalizzare questa cosa, basandosi sull'architettura dell'altra volta. Dobbiamo arrivare a ottenere sw eseguibile.
Per comandare il led direttamente bisogna scrivere qualcosa sulla seriale. Se non sappiamo accendere il led dobbiamo delegare ad altri quello che c'è da fare, nel dettaglio. E' questa la pianificazione del lavoro. Il metamodello è capace di leggere o scrivere dalla seriale? Built-in no. Quindi so come progettista è che questa cosa la devo fare a mano. Possiamo utilizzare il comando built-in "javaRun" per poter mettere in esecuzione codice java che farà quello che noi non sappiamo fare.
Guardiamo il package "it.unibo.utils.arduino" dentro "naive": l'idea è che qualcuno ha organizzato del codice che mi permette di interagire con Arduino.
Nel modello trovo chiamate "sendToArduino" con "javaRun", quindi sto dicendo che delego a un programmatore java delle utilities per inviare e ricevere dati da arduino.
In connArduino.java troviamo anche la initPc, o initRasp, che inizializza la connessione sulla seriale verso arduino. Questo è fatto dall'implementatore, che riceve istruzioni dal progettista, che a sua volta riceve info dall'analista.
Guardiamo il bls1.qa del progetto del prof (progetto "naive.qa"): nel qaactuator init si ha l'inizializzazione di una gui con un led mock. Lo eseguiamo e vediamo che il led cambia stato tre volte, questo potrebbe portarmi a progettare un sistema di testing automatizzato con JUnit.
Se guardiamo il qacontrol nel file bls1 del prof vediamo che ci sono delle regole prolog. 
Anche se ho raspberry e arduino devo usare i mock, per far vedere la parte logica al committente.
Pattern bridge paragrafo 1.3 del nodeLab2018.
Guardiamo il paragrafo 2.3 del nodeLab2018: il controller non vede più la parte tecnology dependent, lavora sulla base di un modello (di sensore o di attuatore). Il controller diventa un invariante all'interno della mia applicazione.
Formalizziamo l'architettura 2.3...non riusciamo perchè ci mancano degli elementi.
Ragioniamo come analisti, cosa deve succedere quando premo sul bottone rispetto all'architettura fuffosa in figura? Cambia lo stato del sensor model. Il modello qui rappresenta lo stato del bottone come entità logica.
Cosa ci guadagno con questa architettura? Il modello è un disaccoppiatore, disaccoppio modello fisico con business logic.
La visione è che voglio modificare il meno possibile il modello del sensore (o dell'attuatore), perchè cattura le info del mio settore industriale, ci ho messo conoscenza propria. Ho separato la mente, il modello di sensore, con il corpo, cioè l'implementazione del sensore.

*** a casa scaricare Docker, infrastruttura molto leggera come alternativa a VM ***

Facciamo un nuovo QActor chiamato bls1m.qa (vedi paragrafo 2.3). Adesso il sensore (button) è modellato all'interno del controller, quindi ho solo due entità in gioco.
Paragrafo 2.3.1: il fatto sancisce che ???
C'è una teoria prolog caricata a nostra insaputa, chiamata "WorldTheory.pl" (in "it.unibo.bls17.naive.qa/srcMore/it/unibo/qasensor/WorldTheory.pl"). Se abbiamo un dubbio che qualcosa esiste andiamo a consultare la WorldTheory, che viene in parte espressa in maniera fisssa e in parte generata.
Guardiamo paragrafo 2.3.2: è già organizzato che quando premo genero un evento local_click, in più c'è una trasformazione da evanto a messaggio.
Dobbiamo accendere il led su arduino, dove mettiamo le mani? Nel modello.
Il codice è ancora un po' troppo cablato, va bene dal punto di vista logico ma non come progettista. Quindi va tolto il javaRun e messi i messaggi.

Architettura esagonale: al centro c'è il modello delle risorse. L'idea è che qualunque cosa si faccia si deve concentrare la propria attenzione su un resource model.
Paragrafo 2.4.1: potrei automatizzare il passaggio da una specifica di quel livello al json? Sì, ma perdo la capacità di lavorare in maniera referenziale sulla base di conoscenza. Listing 1.10: getModelItem fa una query sul modello, changeModelItem mi permette di modificare il modello. Tutte le volte che cambia il modello invoca la changedModelAction (che dobbiamo scrivere noi).
Guardiamo blsMVC.qa: quando qualcuno genera inputCtrlEvent viene fatta l'unificazione con inputEvent dove spero qualcuno mi mandi degli argomenti.
"demo" serve per dimostrare che una teoria è vera, in pratica mette in esecuzione.
blsMVC: la changeModelItem cambia il modello, ma lo sto cambiando dal punto di vista dell'attuatore. Questo innesca altre modifiche di modello.
Si fa girare blsMVCCtx.java e si vede il led mock.

Oggi siamo passati da un architettura naive a una più cablata, l'architettura di riferimento ha una business logic a livello di controller (paragrafo 2.4 MVC), quando devo passare da modello a implementazione lo faccio tramite eventi o messaggi.