Pull dalle repositories.
Apriamo EventProgramming1.pdf, è un'introduzione alla progammazione funzionale in js e node.
In js funzione di callback (chiusura lessicale), c'è il rischio di "callback hell".
Installare Node.js su raspberry + npm per gestire le dipendenze.
Ottimizzazione tail non c'è, cioè non posso usare un solo record di attivazione per chiamate ricorsive in coda. "Trampoline" è un modo per ovviare alla mancanza della tail recursion.
File NodeExpressWeb.pdf: vediamo anche i db no-sql (tipo MongoDB) e la costruzione di server.
Non usare operazioni di GET per cambiare lo stato, meglio usare PUT o POST. Questo è lo stile RESTFul.
Tutte le app di rete attuali sono una riedizione dell'MVC. Faccio in modo di disaccoppiare l'accesso al db mongo in base alle chiamate REST, in modo che se cambio db in un secondo momento non ho problemi.
Express è una libreria che permette di fare le cose nella maniera corretta in fase di costruzione di un server, sia in termini di costi che di tempi.
Deve esserci una comunicazione bidirezionale tra server e client web per poter aggiornare le info in pagina senza dover fare il refresh della pagina, questo può essere fatto tramite websocket o socketIO.
Apriamo pdf NodeLab2018.pdf: nelle scorse volte abbiamo cercato di pensare a una applicazione "premo un bottone ed accendo un led", con l'idea che la logica applicativa non deve essere legata a come è fatto un led. Vogliamo aggiungere un front-end server.
Paragrafo 1.5: il cambio di stato del sensore (di temp.) cambia il resource model. Application logic (controller) può essere l'observer dei cambiamenti del modello, perchè se la temp. va sopra o sotto una soglia farò certe azioni su certi attuatori (es. condizionatore). Come fa il controller a diventare entità observer di un'altra?
Tutte le varie opzioni sono, dal punto di vista implementativo: 
    polling (richieste continue);
    pattern observer (observer che si registra a observable, si usano procedure call);
    pub/sub con mqtt (con sottoscrizioni e scambio di messaggi, è un modo di fare pattern observer nel distribuito);
Mentre dal punto di vista logico, per eliminare le procedure call:
    messaggi
    eventi
Devo sapere dai requisiti che scelta fare e farla in fase architetturale di analisi.
Paragrafo 3.9: simile all'architettura finale.
Guardiamo il file blsMVC nel progetto "naive.qa": quando arriva dall'esterno uno stimolo cambio il modello (riga 59-60). ChangeModelItem è una regola Prolog, ma avrei potuto fare questa cosa in un qualsiasi altro linguaggio, perchè ci interessa la logica non la parte fisica al momento.
La "changeModelItem" è definita nel file "resourceModel.pl", viene fatto un cambiamento di modello. La "changedModelAction" è definita nelle Rules del modello qa.
Se non si è in ascolto di un evento (event-based) allora potrei perdere l'evento se viene scatenato.
Voglio sostituire l'infrastruttura a QActor, utile in fase prototipale, con quella a scambio di messaggi (pub/sub tramite mqtt). La logica è che non voglio cambiare di una virgola di quello che ho fatto in fase di analisi e progettazione, cambierà solo l'implementazione. L'observable anzichè emettere eventi manderà messaggi, ma dal punto di vista logico non cambia praticamente niente.
Non basta il "pubSubServer "tcp://localhost:1883"" per lavorare con mqtt, qualche QActor deve avere il flag "-pubsub". Con questo flag tutte le cose che dal punto di vista logico vengono scritte come eventi, vengono in realtà tradotte in messaggi. Ci si registra sia come subscriber che publisher, quindi l'evento (messaggio) arriva anche a chi lo emette (pubblica). In questo modo ho cambiato radicalmente l'infrastruttura, ma dal punto di vista logico non è cambiato nulla.
Quindi prima di addentrarmi nella valutazione dell'interazione fisica mi interessa guardare l'interazione logica, è l'analista che dice cosa c'è da fare.
Riguardiamo il paragrafo 3.9: come faccio a testare il mio sistema? Sul blsMVC.qa, riga 22, vediamo che c'è un EventHandler che fa un mapping tra "sensorEvent" e "inputEvent".
Per fare un test potrei scrivere un QActor aggiuntivo che emette un ctrlEvent, ma vogliamo fare test senza cambiare codice.
Cos'è il punt 2 dell'immagine? E' un server, quando mi collego ad esso devo poter accendere/spegnere il led a comando, quindi mi serve una GUI in modo che sia comandabile da un utente umano. Quindi facciamo quest server in node.
Il 3a è human to machine, è una pagina web.
Il led potrebbe essere di vari tipi, su raspberry, su arduino, ecc...è una parte technology dependent, ma non voglio cambiare il mio codice di una riga.
C'è un qa per il led mock e uno per il led su raspberry. Il led mock è modellato da ledMockGui.qa: nel piano iniziale viene creata la gui, poi acceso e spento il led in sequenza. Dopodiché rimane in attesa di un ctrlEvent, che viene poi tradotto in una chiamata implementativa a codice java.
Nel ledOnRasp rispetto a led mock cambia solo il COMPORTAMENTO, non cambiano struttura ed interazione.
4a e 4b: chiunque può percepire certi eventi/messaggi può operare nel sistema (es. diversi tipi di led).
5: è un adapter che posso attaccare e che fa da observable al modello, quindi tutte le volte che cambia il modello esso fa qualcosa.

Vogliamo costruire il punto 2, cioè il frontend server node con il quale inviare comandi RESTFul per agire sulle risorse in lettura o scrittura.
Paragrafo 3.1 da seguire per iniziare (attenzione: installare express-generator, non solo express). Dopodiché lanciare "node bin/www" per lanciare il server node.
Seguiamo il passo 3.2.
"Jade" è il generatore automatico di pagine html.
Paragrafo 3.4: creaiamo un nuovo file "frontend.js".

Guardiamo applCode.js, riga 34: tutte le volte che arriva una query senza altri parametri allora si fa vedere la pagina html di indice. Se invece si va su "/pi/actuators" viene eseguito "actuatorsRoutes".
Riga 42: viene mandata una risposta a chi l'ha chiamato, con un certo body testuale.

Copiare dal progetto del prof tutta la cartella "routes" e model.js e resources.json da "models".
