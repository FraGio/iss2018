Pull dalle repository.
Nella fase di analisi dei requisiti bisogna modellare le risorse che il committente ci dà.
Nel caso attuale è il led.
Dobbiamo delineare un modello della risorsa (led), in termini di struttura, interazione e comportamento.
Apriamo file "ledOnRasp" in progetto "...bls17.ledrasp.qa".
Devo sempre assumere che il QA non l'abbia mai visto in vita mia.
Nel qa ledrasp c'è un solo attore che agisce in un solo contesto. L'actor è componente attivo che interagisce col mondo esterno con eventi.
E' in ascolto di eventi ctrlEvent, poi va nell'handler. Siccome vediamo "javaOp" vuol dire che è stato chiamato un esperto, vengono eseguite operazioni java.
Senza questo modello avrei avuto un abstraction gap enorme tra led fisico e codice operativo. Avremmo dovuto chiederci cosa fare quando si voleva accendere il led, si doveva scrivere un programma in qualche linguaggio specifico (java, python, ...) che mi permetteva di comandare il led da sw. In questo programma, detto di basso livello, devo scrivere l'operazione di blink del led? No, se penso che ho strutturato funzioni primitive (turnOn, turnOff) sulle quali posso costruire la blink. In questo modo la blink è technology independent. Qual è lo svantaggio? Non sono vicino alla tecnologia, di conseguenza meno ottimizzato (ma è da vedere anche questo). Però se metto il blink direttamente sul led e poi voglio cambiare il comportamento del blink devo cambiare led.

Il componente potrebbe lavorare tramite scambio messaggi pub/sub (mqtt), ma al momento non ci sono invii di messaggi nel modello.
Quando vediamo il flag "-pubsub" vuol dire che quell'attore si vuole avvalere del server mqtt come infrastruttura alternativa all'infrastruttura di supporto dei QActor (che usa TCP). Il flag significa che ci si connette sia come publisher che come subscriber, quindi tutto passa per un mediatore (server). Questo vuol dire che un messaggio pubblicato può anche essere ricevuto dall'entità che l'ha inviato.

Quando facciamo applicazioni IOT possiamo ragionare in termini di mente e corpo. In questo caso il led fa parte del corpo, ma la mente dove la mettiamo? Il raspberry può avere anche la parte di mente? Sì, ma non nel nostro caso, è meglio che vada su pc così chi non ha il raspberry può lavorare.
Facciamo l'architettura logica di questo sistema.
Come analisti da quante parti deve essere costituito il sistema per risolvere i requisiti? Dopo l'analisi dei requisiti so che ho un componente che è il led. Il mio sistema lo faccio tutto con quel componente? No, di sicuro mi serve un'entità che si occupa della business logic, e questa è la prima cosa di cui mi occupo perchè è la più importante. Poi ci sarà anche un bottone, perchè richiesto dal committente.
Il controller interagisce con bottone e led. La prossima domanda è: come interagisce con essi? Il bottone viene naturale pensare che comunichi tramite eventi, non sa con chi sta comunicando.
I requisiti sono che alla prima pressione del bottone il led deve blinkare, al secondo devo spegnere il led. Quindi i requisiti identificano due stati finiti, uno corrispondente al click dispari (blink) e uno al click pari (spegnimento).

Lo stato cattura una memoria di una sequenza di ingressi.

Formalizziamo in blsLedBlink.qa.
Ci vuole un QActor led, che è un emettitore di eventi local_click. Deve anche interagire con con l'utente tramite interfaccia grafica.

C'è un problema di analisi sull'operazione di blinking: è un azione atomica o no? La semantica dell'operazione blink qual è? Se la tratto come operazione che alterna turnOn e turnOff con un delay in mezzo e lo fa per sempre, noi stiamo mettendo una mina. Questo perchè l'operazione non termina, non esco mai da uno stato.
La blink la posso fare esplicitamente, così posso far fermare il tutto se per un po' di tempo non succede niente. Altrimenti posso fare una transizione, ma se nel tempo dato non è arrivato niente posso fare transizione di stato. La blink diventa un'operazione interrompibile.

C'è un accoppiamento indebito tra led e contoller? Sì, quando emettiamo un evento per il led. Il mio led non risponde a comandi di tipo "on" o "off", ci è stato dato un modello in cui il led richiede info su modello, categoria e stato, quindi siamo costretti a dare queste info per accendere il led.
Potrei dire che con lo stesso identico evento potrei pilotare un led model che disaccoppia ulteriormente.

Dobbiamo portare il codice sul raspberry, per farlo guardare il file gradle: c'è una parte che serve per fare la build. Dentro "build/distribution" c'è un file zip, questo lo copiamo sul raspberry, lo unzippiamo e ci comparirà un jar file eseguibile, con le librerie necessarie. La build fa questo zip in automatico.

Eseguire un comando "docker run -ti -p1883:1883 -p 9001:9001 eclipse-mosquitto" per avere un sistema che gira su raspberry che fa da publisher e subscriber.