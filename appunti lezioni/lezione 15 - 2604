Fatti pull dalle repositories.
Abbiamo costruito un sistema distibuito articolato, al posto degli oggetti abbiamo microservizi (che hanno un proprio flusso di controllo).
Siamo sul caseStudy1, capitolo 10: siamo partiti dal radar, non ci interessava come è fatto dentro ma solo come interagire con esso.
C'è anche un virtualRobotExecutor, dall'esterno è possibile inviare comandi eventi usercmd o mindcmd per pilotarlo.

*** far partire il progetto "divide", poi sostituire l'infrastuttura QActor con quella Mqtt. Chiedersi cosa si deve fare per fare questa sostituzione, l'idea è cambiare il meno possibile. Installarsi mosquitto ***

L'idea è scrivere la logica applicativa in un'entità esterna, chiamata mindOfRobot. In questa versione anche la mind ha bisogno del radar (infrastuttura QActor). Quando faremo refactoring con mqtt non avremo più bisogno del pivot radar ma sarà l'mqtt server.

Capitolo 10.3: introduciamo l'argomento testing. E' un elemento essenziale, enfatizzato dai modelli di sviluppo agili. La specifica è difficile da esprimere ma dice quello che io voglio.
Non posso pensare di lavorare per più di mezza giornata senza aver fatto un test.
Il test può essere previsto a priori o a posteriori. Di solito è meglio partire dalla specifica, e pianificare il test in base ad essa.
Diverse strategie di testing: black box, cioè sottopongo a test un qualcosa di cui conosco solo input ed output, mentre white box posso anche vedere come dall'input si arriva all'output.
Un'unità di lavoro lo si decide non a priori, potrebbe essere il radar ad esempio.
Integration testing è l'attività di testing che mette insieme unità diverse in un sistema e valuta se tutto funziona.
Functional testing vuol dire che valuto che l'entità faccia quello che deve fare, es. caffettiera deve fare caffè.
C'è anche il test con stress load, e il test finale di validazione.
JUnit è nato in Java, è scaturito da una visione di automatizzare la fase di test.
Il test-driven development dice che io voglio pianificare e concepire i test prima di produrre codice vero e proprio. In questo modo chi deve creare codice di produzione ha già i test a disposizione per valutarne la correttezza.
E' un altro modo per dire "non c'è codice senza progetto e non c'è progetto senza requisiti".
Supponendo di lavorare in un ambiente virtuale, vogliamo che parta il radar, il virtualRobotExecutor, unity, che il robot passi sotto un sonar e che sul radar compaia una info in una certa posizione.
Guardiamo file TestVirtualRobotExecutor.java in progetto "divide": in Junit abbiamo annotazioni @Before (test eseguiti prima degli altri test) e @After (test eseguiti dopo gli altri test).
initTheContext inizializzerà il contesto dell'elemento.
Rover è un QActor che rappresenta il rover, mentre polaragent è sempre un QActor che fa da eventlogger per gli eventi polar.
createRoverWithoutUser(): sto degradando rover da QActor a oggetto. Rimuovo dalla propria base di conoscenza il fatto "unityConfig(X)", poi mi collego allo unity che sta girando su localhost. Viene poi emesso l'evento di mindcmd per configurare l'avatar.
Guardiamo il test vero e proprio (@Test): l'idea è far andare avanti l'avatar per 3 secondi, sperando che passi sotto al sonar.
polarlogagent.solveGoal("p(X,30)") : X viene legato alla distanza, e la funzione ritorna true (sempre se si è verificato il goal). Questa cosa la testo poi con la assertTrue.
C'è la possibilità di programmare i QActor con diversi paradigmi, come dichiarativo, imperativo o funzionale.
Guardiamo QActor polarlogagent in virtualRobotExecutor.qa: c'è l'aggiunta di una regola alla propria base di conoscenza (addRule). Gli attori sono scatole blindate, solo tramite messaggio o evento riesco a comunicare con essi. Le basi di conoscenza hanno questa caratteristica, solo l'attore corrente è il proprietario.

Nel led button system ho il led che è un mock, cioè una delle tante rappresentazioni possbili. In questo caso il quadrato è una rappresentazione del led, ai fini di automatizzare i test.

Guardiamo il progetto "it.unibo.bls17.naive", classe MainBlsGuiBase. Nella classe ButtonListener actionPerformed ha come argomento un oggetto trattato come evento, non un evento vero e proprio.
Se ho solo due componenti, led e bottone, la logica applicativa avrei dovuto metterla in una o nell'altra. Devo ragionare sull'analisi, il led è un'entità che riceve input e non ha logica applicativa. Posso inserire un terzo componente, che contiene solamente la logica applicativa, utilizzato dal bottone. In questo modo ho modularizzato.

Quindi, in sintesi, progetto il mio sistema di test con JUnit, poi lo passo a chi sviluppa il codice di produzione.

Esempio: facendo "build gradle" sono stati eseguiti i test in automatico, e solo se i test hanno successo viene compilato il codice. In più ho report di JUnit più report avanzato Jacoco che mi dice quali punti del codice non sono coperti dai test.