System reqAnalysisModel


//evento che rappresenta il comand (START o STOP) inviato da GUI a robot
Event robotCmd : robotCmd ( X )

pubSubServer "tcp://localhost"

//contesto Robot
Context ctxRobot ip [ host="localhost"   port=8021 ]

QActor robot context ctxRobot -pubsub {   
	
	
	Rules{
		//copre requisito R-TempOk e R-TempKo
		//NB: da requisiti il robot NON ha sonar di temperatura,
		//quindi la temperatura deve essere fornita al robot da qualcuno
		//o reperita dal robot stesso tramite un'entitÃ /servizio esterno/a.
		limitTemperatureValue( 25 ).
		
		changedModelAction( temperature, tempAmbiente, V  ):-
				limitTemperatureValue( MAX ), 
	 		    eval( ge, V , MAX ), !,   
	 		    output('temperatura sopra limite'),
	 			emitevent( robotCmd,  robotCmd ('STOP') ).
	 		
	 		
	 	//copre requisito R-TimeOk e R-TimeKo		
	 	limitTimeValueMin( 7 ).
		limitTimeValueMax( 10 ).
		
	 	changedModelAction(timee,timeData, T ):-
	 	 		//output(T),
				limitTimeValueMin( MIN ),
				limitTimeValueMax( MAX ),
	 		    eval( le, T , MIN ), !,  
	 		    output('tempo fuori range'),
	 			emitevent( robotCmd,  robotCmd ('STOP') ).
	 			
	 	changedModelAction(timee,timeData, T ):-
	 			//output(T),
				limitTimeValueMin( MIN ),
				limitTimeValueMax( MAX ),
	 		    eval( ge, T , MAX ), !,   
	 		    output('tempo fuori range'),
	 			emitevent( robotCmd,  robotCmd ('STOP') ).
	 			
	}
	  
	Plan init normal [  
		demo consult("./resourceModel.pl");  //contains the models and related rules 
		println("robot START")
	]  
	switchTo waitForCmd 
	 
	//Robot attende comandi
	Plan waitForCmd[
		println("Robot in attesa di comandi")
	]
	transition stopAfter 3600000   	//1h 
  		whenEvent robotCmd -> robotCmdHandler
  	finally repeatPlan 
  	
  	//gestione dei comandi ricevuti da GUI
	Plan robotCmdHandler [
		//coperto il requisito R-TimeOk, R-TimeKo, R-TempOk, R-TempKo
		println("Valutazione TEMPERATURA ed ORARIO");
		
		//coperto il requisito R-FloorClean
		onEvent robotCmd : robotCmd ("START") -> { 
			println("Robot attivia'  avviata"); 
			
			//coperto il requisito R-BlinkLed e R-BlinkHue
			[ !? isRealRobot ] println("Robot fisico: blink led")
					else println("Robot virtuale: blink Red-Hue-Lamp");
					
			delay 5000;
			
			//coperto il requisiti R-AvoidFix
			println("Trovato ostacolo fisso, cerco di evitarlo");
			
			delay 5000;
			
			//coperto il requisiti R-AvoidMobile
			println("Trovato ostacolo mobile, cerco di evitarlo");
			 
			delay 5000;
			
			//coperto il requisiti R-Obstacle
			println("Trovato ostacolo inevitabile, mi arresto");
			emit robotCmd : robotCmd("STOP")
		};
		
		onEvent robotCmd : robotCmd ("STOP") -> { 
			println("Robot attivia'  arrestata"); 
			
			//coperto il requisito R-BlinkLed e R-BlinkHue
			[ !? isRealRobot ] println("Robot fisico: STOP blink led")
					else println("Robot virtuale: STOP blink Red-Hue-Lamp")
		}
	] 
	switchTo waitForCmd
}


QActor sonar2 context ctxRobot -pubsub {   
	  
	Plan init normal [  println("sonar 2 START")   ]  
	switchTo emitRobotCmd 
  	
  	//simulazione comandi START/STOP
	Plan emitRobotCmd [	
		delay 15000;
		println("Sonar2: robot rilevato");	
		
		//coperto il requisiti R-End
		emit robotCmd : robotCmd("STOP")
	]
}

QActor sonar1 context ctxRobot -pubsub {   
	  
	Plan init normal [  println("sonar 1 START")   ]  
}
